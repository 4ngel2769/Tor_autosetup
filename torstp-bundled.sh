#!/bin/bash

# Tor Hidden Service Setup Script - Bundled Version
# Auto-generated from modular components
# 
# Generated on: 2025-09-05 19:47:15
# Generated by: Angel@WORKSTATION-4X
# Bundle method: PowerShell bundler (Unix line endings)
# Minified: No
#
# This is a bundled version of the modular Tor setup script
# Original modules: utils.sh, funcs.sh, services.sh, main.sh
# 
# For the latest version and source code, visit:
# https://github.com/your-repo/tor-setup-script

set -euo pipefail


# =============================================================================
# START OF: utils.sh
# =============================================================================

# shellcheck disable=SC2034

# utils.sh - Constants and utility definitions
# This file contains all configuration constants and basic utilities

# Color definitions (using ANSI escape codes - no external dependencies)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m'
GREY='\033[38;5;239m'
LIME="\033[38;5;10m"
BLURPLE="\033[38;5;63m"

# Global flags
VERBOSE=false

# Configuration
TORRC_FILE="/etc/tor/torrc"
HIDDEN_SERVICE_BASE_DIR="/var/lib/tor"
HIDDEN_SERVICE_DIR=""  # Will be set dynamically
TEST_SITE_BASE_PORT=5000
TEST_SITE_PORT=""  # Will be set dynamically
TEST_SITE_BASE_DIR="/var/www/tor-test"
TEST_SITE_DIR=""  # Will be set dynamically

# Service tracking
SERVICES_FILE="$HOME/.torstp/.services_available"
TORSTP_DIR="$HOME/.torstp"

# Global variables
DISTRO=""
PACKAGE_MANAGER=""
INSTALL_CMD=""
SERVICE_MANAGER=""

# Function to print verbose output
verbose_log() {
    if [[ "$VERBOSE" == true ]]; then
        print_colored "$CYAN" "[VERBOSE] $1"
    fi
}

# Function to print colored output
print_colored() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to generate random string
generate_random_string() {
    local length=${1:-9}
    tr -dc 'a-z0-9' < /dev/urandom | head -c "$length"
}

# Function to check if running as root
check_root() {
    verbose_log "Checking if running as root..."
    if [[ $EUID -ne 0 ]]; then
        print_colored "$RED" "‚ùå This script must be run as root!"
        print_colored "$YELLOW" "Please run: sudo $0"
        exit 1
    fi
    verbose_log "‚úÖ Running as root"
}

# Function to print header
print_header() {
    clear
    print_colored "$PURPLE" "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
    print_colored "$PURPLE" "‚ïë                   Tor Hidden Service Setup                   ‚ïë"
    print_colored "$PURPLE" "‚ïë                    Automated Installation                    ‚ïë"
    print_colored "$PURPLE" "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
    echo
    if [[ "$VERBOSE" == true ]]; then
        print_colored "$CYAN" "[VERBOSE MODE ENABLED]"
        echo
    fi
}

# =============================================================================
# END OF: utils.sh
# =============================================================================


# =============================================================================
# START OF: funcs.sh
# =============================================================================



# funcs.sh - Reusable helper functions
# This file contains system detection, package management, and UI functions

# Function to detect distribution and package manager
detect_system() {
    print_colored "$BLUE" "üîç Detecting system distribution..."
    verbose_log "Checking available package managers..."
    
    if command -v apt-get >/dev/null 2>&1; then
        PACKAGE_MANAGER="apt"
        INSTALL_CMD="apt-get"
        verbose_log "Found apt-get package manager"
        if [[ -f /etc/debian_version ]]; then
            DISTRO="debian"
            verbose_log "Detected Debian distribution"
        elif [[ -f /etc/ubuntu-release ]] || grep -q "Ubuntu" /etc/os-release 2>/dev/null; then
            DISTRO="ubuntu"
            verbose_log "Detected Ubuntu distribution"
        else
            DISTRO="debian-based"
            verbose_log "Detected Debian-based distribution"
        fi
    elif command -v yum >/dev/null 2>&1; then
        PACKAGE_MANAGER="yum"
        INSTALL_CMD="yum"
        DISTRO="rhel-based"
        verbose_log "Found yum package manager (RHEL-based)"
    elif command -v dnf >/dev/null 2>&1; then
        PACKAGE_MANAGER="dnf"
        INSTALL_CMD="dnf"
        DISTRO="fedora-based"
        verbose_log "Found dnf package manager (Fedora-based)"
    elif command -v pacman >/dev/null 2>&1; then
        PACKAGE_MANAGER="pacman"
        INSTALL_CMD="pacman"
        DISTRO="arch-based"
        verbose_log "Found pacman package manager (Arch-based)"
    elif command -v zypper >/dev/null 2>&1; then
        PACKAGE_MANAGER="zypper"
        INSTALL_CMD="zypper"
        DISTRO="suse-based"
        verbose_log "Found zypper package manager (SUSE-based)"
    else
        print_colored "$RED" "‚ùå Unsupported package manager detected!"
        print_colored "$YELLOW" "This script supports: apt, yum, dnf, pacman, zypper"
        exit 1
    fi
    
    # Detect service manager
    verbose_log "Checking service manager..."
    if command -v systemctl >/dev/null 2>&1; then
        SERVICE_MANAGER="systemd"
        verbose_log "Found systemd service manager"
    elif command -v service >/dev/null 2>&1; then
        SERVICE_MANAGER="sysv"
        verbose_log "Found SysV service manager"
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Warning: No supported service manager found"
        SERVICE_MANAGER="none"
        verbose_log "No supported service manager found"
    fi
    
    print_colored "$GREEN" "‚úÖ Detected: $DISTRO ($PACKAGE_MANAGER) with $SERVICE_MANAGER"
    verbose_log "System detection complete"
    sleep 2
}

# Function to create interactive menu
show_menu() {
    local title=$1
    shift
    local options=("$@")
    local selected=0
    
    while true; do
        clear
        print_header
        print_colored "$CYAN" "$title"
        echo
        
        for i in "${!options[@]}"; do
            if [[ $i -eq $selected ]]; then
                print_colored "$GREEN" "‚ñ∫ ${options[$i]}"
            else
                print_colored "$WHITE" "  ${options[$i]}"
            fi
        done
        
        echo
        print_colored "$YELLOW" "Use ‚Üë/‚Üì arrow keys to navigate, Enter to select"
        
        read -rsn1 key
        case $key in
            $'\x1b')  # ESC sequence
                read -rsn2 key
                case $key in
                    '[A') ((selected > 0)) && ((selected--)) ;;  # Up arrow
                    '[B') ((selected < ${#options[@]} - 1)) && ((selected++)) ;;  # Down arrow
                esac
                ;;
            '') return $selected ;;  # Enter key
        esac
    done
}

# Function to ask yes/no question
ask_yes_no() {
    local question=$1
    local options=("Yes" "No")
    
    show_menu "$question" "${options[@]}"
    return $?
}

# Function to install packages based on distribution
install_packages() {
    local packages=("$@")
    
    print_colored "$BLUE" "üì¶ Installing packages: ${packages[*]}"
    verbose_log "Package manager: $PACKAGE_MANAGER"
    verbose_log "Install command: $INSTALL_CMD"
    
    case $PACKAGE_MANAGER in
        "apt")
            verbose_log "Updating package list..."
            apt-get update -qq
            verbose_log "Installing packages with apt-get..."
            apt-get install -y "${packages[@]}"
            ;;
        "yum"|"dnf")
            verbose_log "Installing packages with $INSTALL_CMD..."
            $INSTALL_CMD install -y "${packages[@]}"
            ;;
        "pacman")
            verbose_log "Installing packages with pacman..."
            pacman -Syu --noconfirm "${packages[@]}"
            ;;
        "zypper")
            verbose_log "Installing packages with zypper..."
            zypper install -y "${packages[@]}"
            ;;
    esac
    verbose_log "Package installation completed"
}

# Function to check if Tor is installed
check_tor_installation() {
    if command -v tor >/dev/null 2>&1; then
        print_colored "$GREEN" "‚úÖ Tor is already installed"
        return 0
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Tor is not installed"
        return 1
    fi
}

# Function to install Tor
install_tor() {
    print_colored "$BLUE" "üîß Installing Tor..."
    
    case $PACKAGE_MANAGER in
        "apt")
            install_packages tor
            ;;
        "yum"|"dnf")
            install_packages tor
            ;;
        "pacman")
            install_packages tor
            ;;
        "zypper")
            install_packages tor
            ;;
    esac
    
    print_colored "$GREEN" "‚úÖ Tor installation completed"
}

# Function to find available port
find_available_port() {
    local base_port=$1
    local test_port=$base_port
    
    verbose_log "Looking for available port starting with: $base_port"
    
    while ss -tlpn | grep -q ":$test_port "; do
        verbose_log "Port $test_port is in use, trying next..."
        ((test_port++))
        if [[ $test_port -gt 65535 ]]; then
            print_colored "$RED" "‚ùå No available ports found"
            exit 1
        fi
    done
    
    verbose_log "Found available port: $test_port"
    echo "$test_port"
}

# Function to manage Tor service
manage_tor_service() {
    local action=$1
    
    case $SERVICE_MANAGER in
        "systemd")
            systemctl "$action" tor
            ;;
        "sysv")
            service tor "$action"
            ;;
        *)
            print_colored "$YELLOW" "‚ö†Ô∏è  Please manually $action Tor service"
            return 1
            ;;
    esac
}

# Function to install web dependencies
install_web_dependencies() {
    print_colored "$BLUE" "üì¶ Installing web dependencies..."
    
    # Check if Python3 is installed
    if ! command -v python3 >/dev/null 2>&1; then
        verbose_log "Python3 not found, installing..."
        case $PACKAGE_MANAGER in
            "apt")
                install_packages python3
                ;;
            "yum"|"dnf")
                install_packages python3
                ;;
            "pacman")
                install_packages python
                ;;
            "zypper")
                install_packages python3
                ;;
        esac
    else
        print_colored "$GREEN" "‚úÖ Python3 is already installed"
        verbose_log "Python3 found: $(python3 --version)"
    fi
    
    # Check if curl is installed (for server testing)
    if ! command -v curl >/dev/null 2>&1; then
        verbose_log "curl not found, installing..."
        case $PACKAGE_MANAGER in
            "apt")
                install_packages curl
                ;;
            "yum"|"dnf")
                install_packages curl
                ;;
            "pacman")
                install_packages curl
                ;;
            "zypper")
                install_packages curl
                ;;
        esac
    else
        verbose_log "curl is already installed"
    fi
    
    print_colored "$GREEN" "‚úÖ Web dependencies installed"
}

# =============================================================================
# END OF: funcs.sh
# =============================================================================


# =============================================================================
# START OF: services.sh
# =============================================================================



# services.sh - Service management functions
# This file contains all functions related to managing Tor hidden services

# Function to check if service is script-managed
is_script_managed() {
    local service_name="$1"
    # Script-managed services follow pattern: hidden_service_[random]
    [[ "$service_name" =~ ^hidden_service_[a-z0-9]{9}$ ]]
}

# Function to get PID file path for a service
get_pid_file() {
    local service_name="$1"
    echo "$TORSTP_DIR/${service_name}.pid"
}

# Function to initialize service tracking
init_service_tracking() {
    verbose_log "Initializing service tracking..."
    
    # Create .torstp directory if it doesn't exist
    if [[ ! -d "$TORSTP_DIR" ]]; then
        mkdir -p "$TORSTP_DIR"
        verbose_log "Created .torstp directory: $TORSTP_DIR"
    fi
    
    # Create or update services file
    if [[ ! -f "$SERVICES_FILE" ]]; then
        cat > "$SERVICES_FILE" << 'EOF'
# Tor Hidden Services Registry
# Format: SERVICE_NAME|DIRECTORY|PORT|ONION_ADDRESS|WEBSITE_DIR|STATUS|CREATED_DATE
# Status: ACTIVE, INACTIVE, ERROR
EOF
        verbose_log "Created services registry file: $SERVICES_FILE"
    else
        # Check if header exists, if not add it
        if ! grep -q "^# Tor Hidden Services Registry" "$SERVICES_FILE" 2>/dev/null; then
            local temp_file=$(mktemp)
            cat > "$temp_file" << 'EOF'
# Tor Hidden Services Registry
# Format: SERVICE_NAME|DIRECTORY|PORT|ONION_ADDRESS|WEBSITE_DIR|STATUS|CREATED_DATE
# Status: ACTIVE, INACTIVE, ERROR
EOF
            cat "$SERVICES_FILE" >> "$temp_file"
            mv "$temp_file" "$SERVICES_FILE"
            verbose_log "Added header to existing services registry file"
        fi
    fi
    
    # Scan existing services and update registry
    scan_existing_services
}

# Function to scan existing services from torrc
scan_existing_services() {
    verbose_log "Scanning existing services from torrc..."
    
    if [[ ! -f "$TORRC_FILE" ]]; then
        verbose_log "No torrc file found"
        return 0
    fi
    
    local temp_file=$(mktemp)
    local current_dir=""
    local current_port=""
    
    # Read torrc and find hidden service configurations
    while read -r line; do
        if [[ "$line" =~ ^HiddenServiceDir[[:space:]]+(.+)$ ]]; then
            current_dir="${BASH_REMATCH[1]}"
            current_dir="${current_dir%/}"  # Remove trailing slash
        elif [[ "$line" =~ ^HiddenServicePort[[:space:]]+[0-9]+[[:space:]]+127\.0\.0\.1:([0-9]+)$ ]] && [[ -n "$current_dir" ]]; then
            current_port="${BASH_REMATCH[1]}"
            
            # Extract service name from directory
            local service_name=$(basename "$current_dir")
            local onion_address=""
            local status="INACTIVE"
            
            # Try to read onion address
            if [[ -f "$current_dir/hostname" ]]; then
                onion_address=$(cat "$current_dir/hostname" 2>/dev/null || echo "")
                if [[ -n "$onion_address" ]]; then
                    status="ACTIVE"
                fi
            fi
            
            # Check if service already exists in registry
            if ! grep -q "^$service_name|" "$SERVICES_FILE" 2>/dev/null; then
                local created_date=$(date '+%Y-%m-%d %H:%M:%S')
                local website_dir=""
                # Only set website_dir for script-managed services
                if is_script_managed "$service_name"; then
                    website_dir="$TEST_SITE_BASE_DIR/$service_name"
                fi
                echo "$service_name|$current_dir|$current_port|$onion_address|$website_dir|$status|$created_date" >> "$temp_file"
                verbose_log "Found existing service: $service_name ($current_dir:$current_port) [Managed: $(is_script_managed "$service_name" && echo "YES" || echo "NO")]"
            fi
            
            current_dir=""
            current_port=""
        fi
    done < "$TORRC_FILE"
    
    # Append new services to registry
    if [[ -s "$temp_file" ]]; then
        cat "$temp_file" >> "$SERVICES_FILE"
        verbose_log "Added $(wc -l < "$temp_file") existing services to registry"
    fi
    
    rm -f "$temp_file"
}

# Function to add service to registry
add_service_to_registry() {
    local service_name="$1"
    local directory="$2"
    local port="$3"
    local onion_address="$4"
    local website_dir="$5"
    local status="$6"
    local created_date=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "$service_name|$directory|$port|$onion_address|$website_dir|$status|$created_date" >> "$SERVICES_FILE"
    verbose_log "Added service to registry: $service_name"
}

# Function to update service in registry
update_service_in_registry() {
    local service_name="$1"
    local field="$2"
    local value="$3"
    
    local temp_file=$(mktemp)
    
    while IFS='|' read -r name dir port onion website status created; do
        if [[ "$name" == "$service_name" ]]; then
            case "$field" in
                "onion_address") onion="$value" ;;
                "status") status="$value" ;;
                "website_dir") website="$value" ;;
                "port") port="$value" ;;
            esac
        fi
        echo "$name|$dir|$port|$onion|$website|$status|$created"
    done < "$SERVICES_FILE" > "$temp_file"
    
    mv "$temp_file" "$SERVICES_FILE"
    verbose_log "Updated service $service_name: $field=$value"
}

# Function to sync registry with actual service status
sync_registry_status() {
    verbose_log "Syncing registry with actual service status..."
    
    if [[ ! -f "$SERVICES_FILE" ]]; then
        verbose_log "No services file found, skipping sync"
        return 0
    fi
    
    local temp_file=$(mktemp)
    local updated=false
    
    # Read the services file line by line
    while IFS='|' read -r name dir port onion website status created || [[ -n "$name" ]]; do
        # Skip comments and empty lines
        if [[ "$name" =~ ^#.*$ ]] || [[ -z "$name" ]]; then
            echo "$name|$dir|$port|$onion|$website|$status|$created" >> "$temp_file"
            continue
        fi
        
        verbose_log "Processing service: $name"
        
        local new_status="$status"
        local new_onion="$onion"
        
        # Check if hostname file exists and read onion address
        if [[ -f "$dir/hostname" ]]; then
            local actual_onion
            actual_onion=$(cat "$dir/hostname" 2>/dev/null | tr -d '\n' | tr -d ' ')
            
            if [[ -n "$actual_onion" ]]; then
                new_status="ACTIVE"
                new_onion="$actual_onion"
                if [[ "$status" != "ACTIVE" ]] || [[ "$onion" != "$actual_onion" ]]; then
                    updated=true
                    verbose_log "Updated $name: status=$new_status, onion=$actual_onion"
                fi
            fi
        else
            # Check if service is supposed to be active but hostname doesn't exist
            if [[ "$status" == "ACTIVE" ]]; then
                new_status="INACTIVE"
                new_onion=""
                updated=true
                verbose_log "Updated $name: status=INACTIVE (hostname missing)"
            fi
        fi
        
        echo "$name|$dir|$port|$new_onion|$website|$new_status|$created" >> "$temp_file"
        
    done < "$SERVICES_FILE"
    
    mv "$temp_file" "$SERVICES_FILE"
    
    if [[ "$updated" == true ]]; then
        verbose_log "Registry status synchronized"
    else
        verbose_log "Registry status already up to date"
    fi
}

# Function to check if web server is actually running and responding
check_web_server_status() {
    local port="$1"
    local timeout=3
    
    # Check if port is listening
    if ! ss -tlpn 2>/dev/null | grep -q ":$port "; then
        echo "NOT_LISTENING"
        return 1
    fi
    
    # Try to curl the service with a short timeout
    if curl -s --connect-timeout "$timeout" --max-time "$timeout" "http://127.0.0.1:$port" >/dev/null 2>&1; then
        echo "RUNNING"
        return 0
    else
        echo "NOT_RESPONDING"
        return 1
    fi
}

# Function to get comprehensive web server status
get_web_server_status() {
    local service_name="$1"
    local port="$2"
    local website_dir="$3"
    
    # For non-script-managed services, check if port is active
    if ! is_script_managed "$service_name"; then
        if [[ -n "$port" ]]; then
            check_web_server_status "$port"
        else
            echo "N/A"
        fi
        return
    fi
    
    # For script-managed services, check both PID and actual response
    local pid_file=$(get_pid_file "$service_name")
    local pid_status="UNKNOWN"
    local web_status="UNKNOWN"
    
    # Check PID file
    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            pid_status="PID_ALIVE"
        else
            pid_status="PID_DEAD"
            rm -f "$pid_file" 2>/dev/null
        fi
    else
        pid_status="NO_PID"
    fi
    
    # Check actual web server response
    if [[ -n "$port" ]]; then
        web_status=$(check_web_server_status "$port")
    fi
    
    # Determine final status
    case "$web_status" in
        "RUNNING")
            echo "RUNNING"
            ;;
        "NOT_LISTENING")
            echo "STOPPED"
            ;;
        "NOT_RESPONDING")
            if [[ "$pid_status" == "PID_ALIVE" ]]; then
                echo "UNRESPONSIVE"
            else
                echo "STOPPED"
            fi
            ;;
        *)
            echo "UNKNOWN"
            ;;
    esac
}

# Function to start server with PID tracking
start_test_server() {
    print_colored "$BLUE" "üöÄ Starting test web server on port $TEST_SITE_PORT..."
    
    local service_name=$(basename "$HIDDEN_SERVICE_DIR")
    local pid_file=$(get_pid_file "$service_name")
    
    # Double-check if port is available
    if ss -tlpn | grep -q ":$TEST_SITE_PORT "; then
        print_colored "$YELLOW" "‚ö†Ô∏è  Port $TEST_SITE_PORT became unavailable"
        print_colored "$RED" "‚ùå Cannot start server - port conflict detected"
        print_colored "$CYAN" "You can manually start it later with:"
        print_colored "$WHITE" "cd $TEST_SITE_DIR && python3 server.py"
        return 1
    fi
    
    # Start server in background and save PID
    cd "$TEST_SITE_DIR" || exit
    nohup python3 server.py > server.log 2>&1 &
    local server_pid=$!
    echo "$server_pid" > "$pid_file"
    
    sleep 2
    
    # Check if server started successfully
    if curl -s "http://127.0.0.1:$TEST_SITE_PORT" >/dev/null 2>&1; then
        print_colored "$GREEN" "‚úÖ Test web server started successfully on port $TEST_SITE_PORT (PID: $server_pid)"
        verbose_log "Web server is running on port $TEST_SITE_PORT with PID $server_pid"
        return 0
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Server may not have started correctly"
        rm -f "$pid_file"
        print_colored "$CYAN" "You can manually start it with:"
        print_colored "$WHITE" "cd $TEST_SITE_DIR && python3 server.py"
        print_colored "$CYAN" "Check logs at: $TEST_SITE_DIR/server.log"
        verbose_log "Web server failed to start on port $TEST_SITE_PORT"
        return 1
    fi
}

# Function to stop web server for a specific service
stop_web_server() {
    local service_name="$1"
    local pid_file=$(get_pid_file "$service_name")
    
    if [[ ! -f "$pid_file" ]]; then
        print_colored "$YELLOW" "‚ö†Ô∏è  No PID file found for service: $service_name"
        return 1
    fi
    
    local pid=$(cat "$pid_file")
    
    if [[ -z "$pid" ]]; then
        print_colored "$YELLOW" "‚ö†Ô∏è  Invalid PID in file for service: $service_name"
        rm -f "$pid_file"
        return 1
    fi
    
    if kill -0 "$pid" 2>/dev/null; then
        if kill "$pid" 2>/dev/null; then
            print_colored "$GREEN" "‚úÖ Stopped web server for $service_name (PID: $pid)"
            rm -f "$pid_file"
            return 0
        else
            print_colored "$RED" "‚ùå Failed to stop web server for $service_name (PID: $pid)"
            return 1
        fi
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Process $pid for $service_name is not running"
        rm -f "$pid_file"
        return 1
    fi
}

# Function to remove service from registry
remove_service_from_registry() {
    local service_name="$1"
    local temp_file=$(mktemp)
    
    # Copy all lines except the one we want to remove
    while IFS='|' read -r name dir port onion website status created; do
        if [[ "$name" != "$service_name" ]]; then
            echo "$name|$dir|$port|$onion|$website|$status|$created"
        fi
    done < "$SERVICES_FILE" > "$temp_file"
    
    mv "$temp_file" "$SERVICES_FILE"
    verbose_log "Removed service $service_name from registry"
}

# Function to remove hidden service from torrc
remove_from_torrc() {
    local service_dir="$1"
    local service_name="$2"
    
    verbose_log "Removing hidden service configuration from torrc..."
    
    # Create backup of torrc before modification
    if [[ -f "$TORRC_FILE" ]]; then
        cp "$TORRC_FILE" "$TORRC_FILE.backup.$(date +%s)"
        verbose_log "Created backup of torrc"
    fi
    
    local temp_file=$(mktemp)
    local in_service_block=false
    local service_removed=false
    
    while IFS= read -r line; do
        # Check if we're entering the service block
        if [[ "$line" =~ ^#.*Hidden.*Service.*Configuration.*-.*$service_name$ ]]; then
            in_service_block=true
            service_removed=true
            verbose_log "Found service block for $service_name, removing..."
            continue
        fi
        
        # Check if we're in the service block
        if [[ "$in_service_block" == true ]]; then
            if [[ "$line" =~ ^HiddenServiceDir[[:space:]]+$service_dir/?$ ]]; then
                verbose_log "Removing HiddenServiceDir line"
                continue
            elif [[ "$line" =~ ^HiddenServicePort.*$ ]]; then
                verbose_log "Removing HiddenServicePort line"
                continue
            elif [[ -z "$line" ]]; then
                # Empty line might be end of block, but continue to next line to check
                continue
            elif [[ "$line" =~ ^[[:space:]]*$ ]]; then
                # Whitespace only line
                continue
            elif [[ "$line" =~ ^# ]] || [[ "$line" =~ ^[A-Za-z] ]]; then
                # Hit another comment or config line, end of our block
                in_service_block=false
                echo "$line" >> "$temp_file"
            else
                # Unknown line in block, skip it
                continue
            fi
        else
            # Not in service block, keep the line
            echo "$line" >> "$temp_file"
        fi
    done < "$TORRC_FILE"
    
    mv "$temp_file" "$TORRC_FILE"
    
    if [[ "$service_removed" == true ]]; then
        print_colored "$GREEN" "‚úÖ Removed hidden service configuration from torrc"
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Hidden service configuration not found in torrc (may have been manually removed)"
    fi
}

# Function to safely remove directories
remove_service_directories() {
    local service_dir="$1"
    local website_dir="$2"
    local service_name="$3"
    
    verbose_log "Removing service directories..."
    
    # Remove hidden service directory
    if [[ -d "$service_dir" ]]; then
        verbose_log "Removing hidden service directory: $service_dir"
        if rm -rf "$service_dir" 2>/dev/null; then
            print_colored "$GREEN" "‚úÖ Removed hidden service directory: $service_dir"
        else
            print_colored "$RED" "‚ùå Failed to remove hidden service directory: $service_dir"
            return 1
        fi
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Hidden service directory not found: $service_dir"
    fi
    
    # Remove website directory if it exists
    if [[ -n "$website_dir" ]] && [[ -d "$website_dir" ]]; then
        verbose_log "Removing website directory: $website_dir"
        if rm -rf "$website_dir" 2>/dev/null; then
            print_colored "$GREEN" "‚úÖ Removed website directory: $website_dir"
        else
            print_colored "$YELLOW" "‚ö†Ô∏è  Failed to remove website directory: $website_dir"
        fi
    fi
    
    # Remove PID file if it exists
    local pid_file=$(get_pid_file "$service_name")
    if [[ -f "$pid_file" ]]; then
        verbose_log "Removing PID file: $pid_file"
        rm -f "$pid_file"
    fi
}

# =============================================================================
# END OF: services.sh
# =============================================================================


# =============================================================================
# START OF: main.sh
# =============================================================================

#!/bin/bash

# main.sh - Entry point and CLI logic
# This file contains the main script logic, CLI parsing, and orchestration

set -euo pipefail

# Determine script directory for sourcing other files

# Source required modules

# Function to show usage
show_usage() {
    echo "Usage: $0 [-V|--verbose] [-l|--list] [-t|--test] [-s|--stop SERVICE_NAME] [-r|--remove SERVICE_NAME] [-h|--help]"
    echo "Options:"
    echo "  -V, --verbose           Enable verbose output for debugging"
    echo "  -l, --list              List all available hidden services with status"
    echo "  -t, --test              Test all services (Tor + web server status)"
    echo "  -s, --stop SERVICE_NAME Stop web server for specific service"
    echo "  -r, --remove SERVICE_NAME Remove hidden service PERMANENTLY"
    echo "  -h, --help              Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 --list                           # List all services with real-time status"
    echo "  $0 --test                           # Test all services comprehensively"
    echo "  $0 --stop hidden_service_abc123def  # Stop web server for specific service"
    echo "  $0 --remove hidden_service_abc123def # PERMANENTLY remove hidden service"
    echo "  $0 -V --list                        # Verbose listing with detailed info"
    exit 0
}

# Function to list available services
list_services() {
    print_colored "$BLUE" "üîç Checking service status..."
    
    # Sync registry before listing
    sync_registry_status
    
    print_colored "$CYAN" "üìã Available Tor Hidden Services:"
    echo
    
    if [[ ! -f "$SERVICES_FILE" ]] || [[ ! -s "$SERVICES_FILE" ]]; then
        print_colored "$YELLOW" "No services found."
        return 0
    fi
    
    printf "%-30s %-6s %-50s %-8s %-10s %-12s\n" "SERVICE NAME" "PORT" "ONION ADDRESS" "STATUS" "MANAGED" "WEB SERVER"
    print_colored "$WHITE" "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    while IFS='|' read -r name dir port onion website status created; do
        # Skip comments and empty lines
        [[ "$name" =~ ^#.*$ ]] || [[ -z "$name" ]] && continue
        
        local display_onion="$onion"
        if [[ -z "$onion" ]]; then
            display_onion="<not generated>"
        elif [[ ${#onion} -gt 45 ]]; then
            display_onion="${onion:0:42}..."
        fi
        
        # Status color
        local status_color_bg=""
        case "$status" in
            "ACTIVE") status_color_bg="${GREEN}" ;;
            "INACTIVE") status_color_bg="${RED}" ;;
            "ERROR") status_color_bg="${RED}" ;;
            *) status_color_bg="${WHITE}" ;;
        esac
        
        # Managed color
        local managed="NO"
        local managed_color_bg=""
        if is_script_managed "$name"; then
            managed="YES"
            managed_color_bg="${WHITE}"
        else
            managed_color_bg="${GREY}"
        fi
        
        # Get comprehensive web server status
        local web_status=$(get_web_server_status "$name" "$port" "$website")
        local web_color_bg=""
        
        case "$web_status" in
            "RUNNING") web_color_bg="${GREEN}" ;;
            "STOPPED") web_color_bg="${YELLOW}" ;;
            "UNRESPONSIVE") web_color_bg="${RED}" ;;
            "NOT_LISTENING") web_color_bg="${RED}" ;;
            "NOT_RESPONDING") web_color_bg="${RED}" ;;
            "N/A") web_color_bg="${WHITE}" ;;
            *) web_color_bg="${WHITE}" ;;
        esac
        
        # Print with custom colors
        printf "${LIME}%-30s${NC} ${BLURPLE}%-6s${NC} ${WHITE}%-50s${NC} ${status_color_bg}%-8s${NC} ${managed_color_bg}%-10s${NC} ${web_color_bg}%-12s${NC}\n" "$name" "$port" "$display_onion" "$status" "$managed" "$web_status"
        
        # Add verbose information if enabled
        if [[ "$VERBOSE" == true ]]; then
            verbose_log "Service $name details:"
            verbose_log "  Directory: $dir"
            verbose_log "  Port: $port"
            verbose_log "  Website: $website"
            verbose_log "  Hostname file: $dir/hostname"
            if [[ -f "$dir/hostname" ]]; then
                verbose_log "  Hostname content: $(cat "$dir/hostname" 2>/dev/null || echo 'ERROR reading file')"
            fi
        fi
        
    done < "$SERVICES_FILE"
    echo
    
    print_colored "$CYAN" "Legend:"
    print_colored "$WHITE" "‚Ä¢ STATUS: Tor hidden service status (ACTIVE/INACTIVE/ERROR)"
    print_colored "$WHITE" "‚Ä¢ MANAGED: Created by this script (YES/NO)"
    print_colored "$WHITE" "‚Ä¢ WEB SERVER: Local web server status"
    print_colored "$GREEN" "  - RUNNING: Server responding to requests"
    print_colored "$YELLOW" "  - STOPPED: No server running on port"
    print_colored "$RED" "  - UNRESPONSIVE: Process exists but not responding"
    print_colored "$RED" "  - NOT_LISTENING: Port not listening"
    print_colored "$WHITE" "  - N/A: Not applicable (external service)"
}

# Function to test all services with real-time status
test_all_services() {
    print_colored "$BLUE" "üß™ Testing all hidden services..."
    
    # Initialize service tracking first
    init_service_tracking
    
    # Debug: Check if services file exists and has content
    if [[ ! -f "$SERVICES_FILE" ]]; then
        print_colored "$YELLOW" "‚ùå Services registry file not found: $SERVICES_FILE"
        print_colored "$CYAN" "üí° Try running: $0 to create a new service first"
        return 1
    fi
    
    # Debug: Show file content (only in verbose mode)
    if [[ "$VERBOSE" == true ]]; then
        print_colored "$CYAN" "[DEBUG] Services file content:"
        cat "$SERVICES_FILE"
        echo "---"
    fi
    
    # Sync registry status
    sync_registry_status
    
    verbose_log "Starting service counting phase..."
    
    # Count actual services (excluding header comments)
    local service_count=0
    local line_count=0
    
    while IFS='|' read -r name dir port onion website status created; do
        ((line_count++))
        verbose_log "Reading line $line_count: name='$name'"
        
        # Skip comments and empty lines
        if [[ "$name" =~ ^#.*$ ]] || [[ -z "$name" ]]; then
            verbose_log "Skipping line $line_count: $name (comment/empty)"
            continue
        fi
        
        ((service_count++))
        verbose_log "Found service $service_count: $name"
        
    done < "$SERVICES_FILE"
    
    verbose_log "Service counting completed: $service_count services found from $line_count lines"
    print_colored "$CYAN" "üìä Found $service_count services in registry (from $line_count total lines)"
    
    if [[ $service_count -eq 0 ]]; then
        print_colored "$YELLOW" "No active services found to test."
        print_colored "$CYAN" "üí° Create a new service by running: $0"
        return 0
    fi
    
    verbose_log "Starting testing phase..."
    
    local tested=0
    local active=0
    local responsive=0
    
    # Test each service - using a temp file approach
    verbose_log "Beginning service testing loop..."
    
    local temp_services=$(mktemp)
    # First, extract just the service lines to a temp file
    while IFS='|' read -r name dir port onion website status created; do
        # Skip comments and empty lines
        if [[ "$name" =~ ^#.*$ ]] || [[ -z "$name" ]]; then
            continue
        fi
        echo "$name|$dir|$port|$onion|$website|$status|$created" >> "$temp_services"
    done < "$SERVICES_FILE"
    
    verbose_log "Created temp services file with $(wc -l < "$temp_services") lines"
    
    # Now test each service from the temp file
    while IFS='|' read -r name dir port onion website status created; do
        ((tested++))
        verbose_log "Testing service $tested: $name"
        
        print_colored "$CYAN" "üîç Testing service $tested/$service_count: $name"
        
        # Debug service details
        verbose_log "Service details: name=$name, dir=$dir, port=$port, status=$status"
        
        # Check Tor service status
        if [[ "$status" == "ACTIVE" ]]; then
            ((active++))
            if [[ -n "$onion" ]]; then
                print_colored "$GREEN" "  ‚úÖ Tor service: ACTIVE ($onion)"
            else
                print_colored "$GREEN" "  ‚úÖ Tor service: ACTIVE (onion address not synced)"
            fi
        else
            print_colored "$YELLOW" "  ‚ö†Ô∏è  Tor service: $status"
        fi
        
        # Check web server if port is available
        if [[ -n "$port" ]]; then
            print_colored "$BLUE" "  üåê Testing web server on port $port..."
            verbose_log "Calling check_web_server_status for port $port"
            
            local web_status
            web_status=$(check_web_server_status "$port")
            verbose_log "Web status result: $web_status"
            
            case "$web_status" in
                "RUNNING")
                    ((responsive++))
                    print_colored "$GREEN" "  ‚úÖ Web server: RUNNING on port $port"
                    ;;
                "NOT_LISTENING")
                    print_colored "$YELLOW" "  ‚ö†Ô∏è  Web server: NOT LISTENING on port $port"
                    ;;
                "NOT_RESPONDING")
                    print_colored "$RED" "  ‚ùå Web server: NOT RESPONDING on port $port"
                    ;;
                *)
                    print_colored "$RED" "  ‚ùå Web server: UNKNOWN STATUS ($web_status)"
                    ;;
            esac
        else
            print_colored "$WHITE" "  ‚ÑπÔ∏è  Web server: No port configured"
        fi
        
        echo
        
    done < "$temp_services"
    
    # Clean up temp file
    rm -f "$temp_services"
    
    verbose_log "Testing phase completed"
    
    # Final summary
    print_colored "$CYAN" "üìä Test Summary:"
    print_colored "$WHITE" "‚Ä¢ Total services tested: $tested"
    print_colored "$WHITE" "‚Ä¢ Active Tor services: $active"
    print_colored "$WHITE" "‚Ä¢ Responsive web servers: $responsive"
    
    if [[ $tested -eq 0 ]]; then
        print_colored "$YELLOW" "‚ö†Ô∏è  No services were actually tested - check registry file"
    fi
    
    verbose_log "test_all_services function completed successfully"
}

# Function to stop web server by service name
stop_service_web_server() {
    local service_name="$1"
    
    if [[ -z "$service_name" ]]; then
        print_colored "$RED" "‚ùå Service name required"
        return 1
    fi
    
    # Check if service exists in registry
    if ! grep -q "^$service_name|" "$SERVICES_FILE" 2>/dev/null; then
        print_colored "$RED" "‚ùå Service '$service_name' not found"
        return 1
    fi
    
    # Check if service is script-managed
    if ! is_script_managed "$service_name"; then
        print_colored "$RED" "‚ùå Service '$service_name' is not managed by this script"
        return 1
    fi
    
    stop_web_server "$service_name"
}

# Function to preview what will be removed
preview_removal() {
    local service_name="$1"
    local service_dir="$2"
    local website_dir="$3"
    local port="$4"
    
    print_colored "$CYAN" "üìã Preview of what will be removed:"
    echo
    print_colored "$WHITE" "Directories to be deleted:"
    print_colored "$RED" "  ‚Ä¢ $service_dir"
    if [[ -n "$website_dir" ]] && [[ -d "$website_dir" ]]; then
        print_colored "$RED" "  ‚Ä¢ $website_dir"
    fi
    
    echo
    print_colored "$WHITE" "Torrc configuration lines to be removed:"
    if grep -q "# Hidden Service Configuration - $service_name" "$TORRC_FILE" 2>/dev/null; then
        print_colored "$RED" "  ‚Ä¢ # Hidden Service Configuration - $service_name"
        print_colored "$RED" "  ‚Ä¢ HiddenServiceDir $service_dir/"
        print_colored "$RED" "  ‚Ä¢ HiddenServicePort 80 127.0.0.1:$port"
    else
        print_colored "$YELLOW" "  ‚Ä¢ No torrc configuration found for this service"
    fi
    
    echo
    print_colored "$WHITE" "Registry entry to be removed:"
    print_colored "$RED" "  ‚Ä¢ Service record for '$service_name'"
    
    if is_script_managed "$service_name"; then
        echo
        print_colored "$WHITE" "Additional cleanup:"
        print_colored "$RED" "  ‚Ä¢ PID files and process tracking"
    fi
}

# Function to remove a hidden service completely
remove_hidden_service() {
    local service_name="$1"
    
    if [[ -z "$service_name" ]]; then
        print_colored "$YELLOW" "Usage: $0 --remove SERVICE_NAME"
        print_colored "$CYAN" "Available services:"
        if [[ -f "$SERVICES_FILE" ]]; then
            while IFS='|' read -r name dir port onion website status created; do
                [[ "$name" =~ ^#.*$ ]] || [[ -z "$name" ]] && continue
                print_colored "$WHITE" "  ‚Ä¢ $name"
            done < "$SERVICES_FILE"
        else
            print_colored "$YELLOW" "  No services found"
        fi
        return 1
    fi
    
    # Check if service exists in registry
    if ! grep -q "^$service_name|" "$SERVICES_FILE" 2>/dev/null; then
        print_colored "$RED" "‚ùå Service '$service_name' not found in registry"
        print_colored "$CYAN" "Available services:"
        if [[ -f "$SERVICES_FILE" ]]; then
            while IFS='|' read -r name dir port onion website status created; do
                [[ "$name" =~ ^#.*$ ]] || [[ -z "$name" ]] && continue
                print_colored "$WHITE" "  ‚Ä¢ $name"
            done < "$SERVICES_FILE"
        else
            print_colored "$YELLOW" "  No services found"
        fi
        return 1
    fi
    
    # Get service details from registry
    local service_info
    service_info=$(grep "^$service_name|" "$SERVICES_FILE" 2>/dev/null)
    
    if [[ -z "$service_info" ]]; then
        print_colored "$RED" "‚ùå Could not retrieve service information"
        return 1
    fi
    
    IFS='|' read -r name dir port onion website status created <<< "$service_info"
    
    # Display service information
    clear
    print_header
    print_colored "$RED" "‚ö†Ô∏è  DANGER: PERMANENT REMOVAL WARNING ‚ö†Ô∏è"
    echo
    print_colored "$YELLOW" "You are about to PERMANENTLY remove the following hidden service:"
    echo
    print_colored "$WHITE" "Service Name: $name"
    print_colored "$WHITE" "Onion Address: ${onion:-'<not generated>'}"
    print_colored "$WHITE" "Port: ${port:-'N/A'}"
    print_colored "$WHITE" "Hidden Service Directory: $dir"
    print_colored "$WHITE" "Website Directory: ${website:-'N/A'}"
    print_colored "$WHITE" "Created: ${created:-'Unknown'}"
    echo
    
    # Show preview of what will be removed
    preview_removal "$service_name" "$dir" "$website" "$port"
    
    echo
    print_colored "$RED" "‚ö†Ô∏è  THIS ACTION CANNOT BE UNDONE! ‚ö†Ô∏è"
    print_colored "$RED" "‚ö†Ô∏è  The .onion address will be LOST FOREVER! ‚ö†Ô∏è"
    print_colored "$RED" "‚ö†Ô∏è  All website files will be DELETED! ‚ö†Ô∏è"
    echo
    
    # Multiple confirmation prompts
    if ! ask_yes_no "Are you ABSOLUTELY SURE you want to remove this hidden service?"; then
        print_colored "$GREEN" "‚úÖ Removal cancelled - service preserved"
        return 0
    fi
    
    if ! ask_yes_no "This will PERMANENTLY DELETE the .onion address. Continue?"; then
        print_colored "$GREEN" "‚úÖ Removal cancelled - service preserved"
        return 0
    fi
    
    if ! ask_yes_no "FINAL WARNING: Remove hidden service '$service_name' forever?"; then
        print_colored "$GREEN" "‚úÖ Removal cancelled - service preserved"
        return 0
    fi
    
    # Stop web server if it's running
    if is_script_managed "$service_name"; then
        print_colored "$BLUE" "üõë Stopping web server..."
        stop_web_server "$service_name" 2>/dev/null || true
    fi
    
    print_colored "$BLUE" "üóëÔ∏è Starting removal process..."
    
    # Remove from torrc
    remove_from_torrc "$dir" "$service_name"
    
    # Remove directories
    remove_service_directories "$dir" "$website" "$service_name"
    
    # Remove from registry
    remove_service_from_registry "$service_name"
    
    # Restart Tor to apply changes
    print_colored "$BLUE" "üîÑ Restarting Tor service to apply changes..."
    if systemctl restart tor 2>/dev/null; then
        print_colored "$GREEN" "‚úÖ Tor service restarted successfully"
    else
        print_colored "$YELLOW" "‚ö†Ô∏è  Please manually restart Tor service: sudo systemctl restart tor"
    fi
    
    print_colored "$GREEN" "‚úÖ Hidden service '$service_name' has been completely removed"
    print_colored "$YELLOW" "üí° The .onion address is now permanently inaccessible"
    
    return 0
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -V|--verbose)
                VERBOSE=true
                print_colored "$GREEN" "‚úÖ Verbose mode enabled"
                shift
                ;;
            -l|--list)
                init_service_tracking
                list_services
                exit 0
                ;;
            -t|--test)
                print_colored "$BLUE" "üîß Initializing service tracking..."
                init_service_tracking
                test_all_services
                exit $?
                ;;
            -s|--stop)
                if [[ -z "${2:-}" ]]; then
                    print_colored "$RED" "‚ùå Service name required for --stop option"
                    print_colored "$YELLOW" "Usage: $0 --stop SERVICE_NAME"
                    show_usage
                fi
                init_service_tracking
                stop_service_web_server "$2"
                exit $?
                ;;
            -r|--remove)
                if [[ -z "${2:-}" ]]; then
                    print_colored "$RED" "‚ùå Service name required for --remove option"
                    print_colored "$YELLOW" "Usage: $0 --remove SERVICE_NAME"
                    init_service_tracking
                    remove_hidden_service ""
                    exit 1
                fi
                init_service_tracking
                remove_hidden_service "$2"
                exit $?
                ;;
            -h|--help)
                show_usage
                ;;
            *)
                print_colored "$RED" "‚ùå Unknown option: $1"
                show_usage
                ;;
        esac
    done
}

# Rest of the main setup functions (configure_tor, start_tor, etc.)
# [Include the remaining functions from your original script here]
# These would include: setup_dynamic_config, configure_tor, start_tor, 
# create_test_website, show_results, and the main() function

# Main installation flow
main() {
    # Parse command line arguments first
    parse_args "$@"
    
    print_header
    check_root
    detect_system
    
    # Show existing services
    init_service_tracking
    list_services
    
    # [Rest of your main logic here]
    
    print_colored "$GREEN" "‚ú® All done! Enjoy your Tor hidden service!"
    verbose_log "Script completed successfully"
}

# Trap to handle cleanup
trap 'print_colored "$RED" "Script interrupted"; exit 1' INT TERM

# Run main function if this script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi

# =============================================================================
# END OF: main.sh
# =============================================================================

