#!/usr/bin/env pwsh

# ================================================================================
# Tor Setup Script Bundler
# ================================================================================
# 
# Description:
#   This PowerShell script bundles modular Tor hidden service setup scripts
#   into a single executable Bash script with Unix line endings. It combines
#   utils.sh, funcs.sh, services.sh, and main.sh into one file for easy
#   deployment on Linux systems.
# 
# Features:
#   - Combines multiple modules into one script
#   - Ensures Unix line endings (LF only)
#   - Optional minification (removes comments and empty lines)
#   - Verbose logging for debugging
#   - Syntax validation via WSL (if available)
# 
# Usage:
#   .\bundle.ps1 [-Verbose] [-Minify] [-Output <filename>] [-Help]
# 
# Credits:
#   Developed by Angel (GitHub: @4ngel2769)
#   Repository: https://github.com/@4ngel2769/tor_autosetup
#
# ================================================================================

param(
    [switch]$Verbose = $false,
    [switch]$Minify = $false,
    [string]$Output = "torstp-bundled.sh",
    [switch]$Help = $false
)

if ($Help) {
    Write-Host @"
Tor Setup Script Bundler

USAGE:
    .\bundle.ps1 [-Verbose] [-Minify] [-Output <filename>] [-Help]

OPTIONS:
    -Verbose    Show detailed bundling process
    -Minify     Remove comments and empty lines (smaller file)
    -Output     Specify output filename (default: torstp-bundled.sh)
    -Help       Show this help message

EXAMPLES:
    .\bundle.ps1                           # Basic bundle
    .\bundle.ps1 -Verbose                  # Verbose output
    .\bundle.ps1 -Minify -Output compact.sh # Minified version
"@ -ForegroundColor Cyan
    exit 0
}

function Write-VerboseLog {
    param([string]$Message)
    if ($Verbose) {
        Write-Host "[VERBOSE] $Message" -ForegroundColor Gray
    }
}

function Write-Status {
    param([string]$Message, [string]$Color = "Cyan")
    Write-Host "üîß $Message" -ForegroundColor $Color
}

function Write-Success {
    param([string]$Message)
    Write-Host "‚úÖ $Message" -ForegroundColor Green
}

function Write-Error {
    param([string]$Message)
    Write-Host "‚ùå $Message" -ForegroundColor Red
}

function Write-Warning {
    param([string]$Message)
    Write-Host "‚ö†Ô∏è  $Message" -ForegroundColor Yellow
}

# Function to write content with Unix line endings
function Write-UnixFile {
    param(
        [string]$FilePath,
        [string[]]$Content,
        [switch]$Append
    )
    
    # Join content with Unix line endings (\n only)
    $unixContent = ($Content -join "`n") + "`n"
    
    # Convert to bytes with UTF-8 encoding (no BOM)
    $utf8NoBom = New-Object System.Text.UTF8Encoding $false
    $bytes = $utf8NoBom.GetBytes($unixContent)
    
    if ($Append) {
        [System.IO.File]::AppendAllText($FilePath, $unixContent, $utf8NoBom)
    } else {
        [System.IO.File]::WriteAllBytes($FilePath, $bytes)
    }
}

Write-Status "Bundling Tor Setup Script modules with Unix line endings..."

# Check if all required files exist
$requiredFiles = @("utils.sh", "funcs.sh", "services.sh", "main.sh")
$missingFiles = @()

Write-VerboseLog "Checking for required files..."
foreach ($file in $requiredFiles) {
    Write-VerboseLog "  Checking: $file"
    if (-not (Test-Path $file)) {
        $missingFiles += $file
        Write-VerboseLog "    ‚ùå Missing: $file"
    } else {
        Write-VerboseLog "    ‚úÖ Found: $file"
    }
}

if ($missingFiles.Count -gt 0) {
    Write-Error "Missing required files:"
    foreach ($file in $missingFiles) {
        Write-Host "  ‚Ä¢ $file" -ForegroundColor Yellow
    }
    Write-Error "Please ensure all module files are in the current directory."
    exit 1
}

Write-Status "Creating bundled script: $Output" "Blue"

try {
    # Create header for bundled script
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $computerName = $env:COMPUTERNAME
    $userName = $env:USERNAME
    
    $headerLines = @(
        "#!/bin/bash",
        "",
        "# Tor Hidden Service Setup Script - Bundled Version",
        "# Auto-generated from modular components",
        "# ",
        "# Generated on: $timestamp",
        "# Generated by: $userName@$computerName",
        "# Bundle method: PowerShell bundler (Unix line endings)",
        "# Minified: $(if ($Minify) { 'Yes' } else { 'No' })",
        "#",
        "# This is a bundled version of the modular Tor setup script",
        "# Original modules: utils.sh, funcs.sh, services.sh, main.sh",
        "# ",
        "# For the latest version and source code, visit:",
        "# https://github.com/4ngel2769/tor_autosetup",
        "",
        "set -euo pipefail",
        ""
    )

    # Write header with Unix line endings
    Write-VerboseLog "Writing header to $Output with Unix line endings"
    Write-UnixFile -FilePath $Output -Content $headerLines

    $totalLines = 0
    $processedLines = 0
    $totalSkipped = 0
    
    # First pass: count total lines for progress
    if ($Verbose) {
        foreach ($file in $requiredFiles) {
            $content = Get-Content $file -Raw
            $lines = $content -split '\r?\n'
            $totalLines += $lines.Count
        }
        Write-VerboseLog "Total lines to process: $totalLines"
    }

    # Process each file and append to bundle
    foreach ($file in $requiredFiles) {
        Write-Status "Processing $file..." "Gray"
        Write-VerboseLog "  Reading file: $file"
        
        # Read file content as raw text and split on any line ending
        $rawContent = Get-Content $file -Raw
        $lines = $rawContent -split '\r?\n'
        
        $filteredLines = @()
        $linesSkipped = 0
        
        # Add separator comment (unless minifying)
        if (-not $Minify) {
            $separatorLines = @(
                "",
                "# =============================================================================",
                "# START OF: $file",
                "# =============================================================================",
                ""
            )
            $filteredLines += $separatorLines
        }
        
        foreach ($line in $lines) {
            $processedLines++
            
            # Skip empty lines at end of file
            if ([string]::IsNullOrWhiteSpace($line) -and $line -eq $lines[-1]) {
                continue
            }
            
            # Skip shebang lines (except in main.sh)
            if ($line -match "^#!/bin/bash" -and $file -ne "main.sh") {
                $linesSkipped++
                Write-VerboseLog "    Skipped shebang: $line"
                continue
            }
            
            # Skip all source-related lines - FIXED REGEX PATTERNS
            if ($line -match "^# shellcheck source=" -or 
                $line -match "^source.*utils\.sh" -or
                $line -match "^source.*funcs\.sh" -or
                $line -match "^source.*services\.sh" -or
                $line -match "^source.*main\.sh" -or
                $line -match "^source.*\`".*dirname.*BASH_SOURCE" -or
                $line -match "^source.*\$.*dirname.*BASH_SOURCE" -or
                $line -match "^source.*\\\$.*SCRIPT_DIR") {
                $linesSkipped++
                Write-VerboseLog "    Skipped source line: $line"
                continue
            }
            
            # Skip SCRIPT_DIR definition since we're bundled
            if ($line -match "^SCRIPT_DIR=") {
                $linesSkipped++
                Write-VerboseLog "    Skipped SCRIPT_DIR definition: $line"
                continue
            }
            
            # Skip 'set -euo pipefail' in individual files (we have it in header)
            if ($line -match "^set -euo pipefail" -and $file -ne "main.sh") {
                $linesSkipped++
                Write-VerboseLog "    Skipped duplicate set statement: $line"
                continue
            }
            
            # Minify options
            if ($Minify) {
                # Skip comments (except important ones)
                if ($line -match "^\s*#" -and 
                    $line -notmatch "#!/bin/bash" -and
                    $line -notmatch "# filepath:" -and
                    $line -notmatch "# shellcheck disable") {
                    $linesSkipped++
                    continue
                }
                
                # Skip empty lines
                if ($line -match "^\s*$") {
                    $linesSkipped++
                    continue
                }
            }
            
            # Add the line
            $filteredLines += $line
        }
        
        # Add end separator (unless minifying)
        if (-not $Minify) {
            $endSeparatorLines = @(
                "",
                "# =============================================================================",
                "# END OF: $file",
                "# =============================================================================",
                ""
            )
            $filteredLines += $endSeparatorLines
        }
        
        Write-VerboseLog "  Lines processed: $($lines.Count), kept: $($filteredLines.Count), skipped: $linesSkipped"
        $totalSkipped += $linesSkipped
        
        # Append filtered content with Unix line endings
        Write-UnixFile -FilePath $Output -Content $filteredLines -Append
    }
    
    Write-Success "Successfully created bundled script!"
    
    # Get file statistics
    $outputItem = Get-Item $Output
    $fileSize = $outputItem.Length
    $fileSizeKB = [math]::Round($fileSize / 1024, 2)
    
    # Count lines by reading as raw and splitting
    $bundledContent = Get-Content $Output -Raw
    $lineCount = ($bundledContent -split '\n').Count
    
    Write-Status "Bundle Statistics:" "Cyan"
    Write-Host "  ‚Ä¢ Output file: $Output" -ForegroundColor White
    Write-Host "  ‚Ä¢ File size: $fileSizeKB KB ($fileSize bytes)" -ForegroundColor White
    Write-Host "  ‚Ä¢ Line count: $lineCount" -ForegroundColor White
    Write-Host "  ‚Ä¢ Lines skipped: $totalSkipped (source statements, shebangs, etc.)" -ForegroundColor Yellow
    Write-Host "  ‚Ä¢ Modules bundled: $($requiredFiles.Count)" -ForegroundColor White
    Write-Host "  ‚Ä¢ Line endings: Unix (LF only)" -ForegroundColor Green
    Write-Host "  ‚Ä¢ Created: $($outputItem.CreationTime)" -ForegroundColor White
    
    if ($Minify) {
        Write-Host "  ‚Ä¢ Minified: Yes (comments and empty lines removed)" -ForegroundColor Yellow
    }
    
    # Verify line endings
    $sampleBytes = [System.IO.File]::ReadAllBytes($Output) | Select-Object -First 1000
    $hasCRLF = ($sampleBytes -contains 13) # Check for carriage return (CR)
    
    if ($hasCRLF) {
        Write-Warning "Warning: File may still contain Windows line endings"
    } else {
        Write-Success "Verified: File uses Unix line endings (LF only)"
    }
    
    # Check for remaining source statements
    $bundledContent = Get-Content $Output -Raw
    if ($bundledContent -match "source.*\.sh") {
        Write-Warning "Warning: Bundle may still contain source statements"
        if ($Verbose) {
            $sourceLines = ($bundledContent -split '\n') | Where-Object { $_ -match "source.*\.sh" }
            foreach ($sourceLine in $sourceLines) {
                Write-Host "    Found: $sourceLine" -ForegroundColor Yellow
            }
        }
    } else {
        Write-Success "Verified: No source statements found in bundle"
    }
    
    # Try to make executable if running on WSL/Linux subsystem
    if (Get-Command "wsl" -ErrorAction SilentlyContinue) {
        Write-Status "Setting executable permissions via WSL..." "Blue"
        try {
            wsl chmod +x $Output
            Write-Success "File permissions set via WSL"
            
            # Test syntax via WSL
            Write-Status "Testing script syntax via WSL..." "Blue"
            $syntaxTest = wsl bash -n $Output 2>&1
            if ($LASTEXITCODE -eq 0) {
                Write-Success "Syntax validation passed!"
            } else {
                Write-Warning "Syntax validation failed:"
                Write-Host $syntaxTest -ForegroundColor Red
            }
        } catch {
            Write-Warning "Could not set permissions via WSL: $($_.Exception.Message)"
        }
    } else {
        Write-Status "üí° To make executable on Linux, run:" "Yellow"
        Write-Host "   chmod +x $Output" -ForegroundColor White
        Write-Host "   # Test syntax with: bash -n $Output" -ForegroundColor Gray
    }
    
    Write-Success "Bundle complete! Transfer to Linux and run:"
    Write-Host "   ./$Output --help" -ForegroundColor White
    Write-Host "   ./$Output --list" -ForegroundColor White
    Write-Host "   ./$Output --test" -ForegroundColor White
    
} catch {
    Write-Error "Error creating bundle: $($_.Exception.Message)"
    Write-VerboseLog "Stack trace: $($_.Exception.StackTrace)"
    exit 1
}
# End of bundle.ps1
